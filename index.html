<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="prefetch" href="https://docs.opencv.org/4.7.0/opencv.js" as="script">
    <link rel="stylesheet" href="styles-mobile.css">
    <title>Extraer Frames con OpenCV.js</title>
</head>
<body>
    <script async src="https://docs.opencv.org/4.7.0/opencv.js" onload="onOpenCvReady();"></script>
    <h1>Extraer Frames de un Video</h1>
    <div style="text-align:center; margin: 1rem 0;">
      <input type="file" id="videoInput" accept="video/*" style="display:none;" />
      <button id="videoUploadBtn" type="button">Seleccionar Video de la Galería</button>
    </div>

    <video id="video" muted>
        <source src="video.mov" type="video/mp4">
        Tu navegador no soporta video.
    </video>
    <div id="totalFramesContainer" style="text-align:center; margin:0.5rem 0; font-size:1.1em; color:#333;">
    </div>

    <div class="controls-container">
        <div class="control-group">
          <label for="cadenceSlider">Cadencia (ms entre frames):</label>
          <input type="range" id="cadenceSlider" min="10" max="1000" value="130" step="1">
        </div>



      <button id="playPauseBtn">Play</button>
    <canvas id="canvas" width="640" height="360" style="display:none;"></canvas>
    <canvas id="canvasOutput" width="640" height="360" style="display:none;"></canvas>
    <canvas id="strobeCanvas" width="640" height="360" style="display:none;"></canvas>
    <canvas id="backgroundCanvas" width="640" height="360"></canvas>
    <div class="control-group">
        <label for="inThreshold">Umbral Inferior:</label>
        <input type="range" id="inThreshold" min="1" max="255" value="10">
        <span id="inThresholdValue" class="threshold-value">10</span>
      </div>
  
      <div class="control-group">
        <label for="outThreshold">Umbral Superior:</label>
        <input type="range" id="outThreshold" min="0" max="255" value="200">
        <span id="outThresholdValue" class="threshold-value">200</span>
      </div>
    </div>
    <div style="text-align:center; margin: 2rem 0;">
      <button id="downloadBackgroundBtn" type="button" class="download-btn">Descargar Imagen Final</button>
      <button id="resetAppBtn" type="button" class="download-btn">Reset</button>
    </div>
    <script type="text/javascript">
        let videoElement = document.getElementById('video');
        let canvasElement = document.getElementById('canvas');
        let context = canvasElement.getContext('2d', { willReadFrequently: true });
        let videoInput = document.getElementById('videoInput');
        let playPauseBtn = document.getElementById('playPauseBtn');
        let videoUploadBtn = document.getElementById('videoUploadBtn');
        const inThresholdSlider = document.getElementById('inThreshold');
        const outThresholdSlider = document.getElementById('outThreshold');
        const inThresholdValue = document.getElementById('inThresholdValue');
        const outThresholdValue = document.getElementById('outThresholdValue');

        let cap, frame;
        let framesArray = [];  // Array para guardar todos los fotogramas
        let allFramesCaptured = false; // Nuevo flag para saber si ya se capturaron todos los frames
        let cadence = 130;
        const cadenceSlider = document.getElementById('cadenceSlider');
        const cadenceValue = document.getElementById('cadenceValue');
        const cadenceLabel = document.querySelector('label[for="cadenceSlider"]');

        videoElement.addEventListener('loadedmetadata', () => {
            const canvas = document.getElementById('canvas');
            const canvasOutput = document.getElementById('canvasOutput');
            const strobeCanvas = document.getElementById('strobeCanvas');
            const backgroundCanvas = document.getElementById('backgroundCanvas');

            videoElement.height = videoElement.videoHeight;
            videoElement.width = videoElement.videoWidth;

            canvas.width = videoElement.videoWidth;
            canvas.height = videoElement.videoHeight;
            canvasOutput.height = videoElement.videoHeight;
            strobeCanvas.width = videoElement.videoWidth;
            strobeCanvas.height = videoElement.videoHeight;
            backgroundCanvas.width = videoElement.videoWidth;
            backgroundCanvas.height = videoElement.videoHeight;
            // Ajustar el máximo del slider según la duración y FPS
            let fps = videoElement.frameRate || 30;
            let maxFrames = Math.floor(videoElement.duration * fps);
            cadenceSlider.max = maxFrames;
            cadenceLabel.textContent = `Frames a procesar: ${cadenceSlider.value}`;
            console.log(videoElement.duration*33, videoElement.frameRate)
        });   

        // Cuando OpenCV está listo, esta función se ejecuta
        const onOpenCvReady = () => {
            console.log("OpenCV.js está listo");       
        };

        // Cuando el usuario carga un video
        videoUploadBtn.addEventListener('click', () => {
            videoInput.click();
        });
        videoInput.addEventListener('change', (event) => {
            let file = event.target.files[0];
            if (file) {
                let url = URL.createObjectURL(file);
                videoElement.src = url;
                videoElement.load();
                videoElement.onloadedmetadata = function() {
                    const width = videoElement.videoWidth;
                    const height = videoElement.videoHeight;
                    ["canvas","canvasOutput","strobeCanvas","backgroundCanvas"].forEach(id => {
                        const c = document.getElementById(id);
                        c.width = width;
                        c.height = height;
                    });
                };
                
            } else {
                videoElement.src = "video.mov";
                videoElement.load();
                
            }
        });

        // Función para extraer todos los frames del video
        const extractAllFrames = () => {
            framesArray = [];
            allFramesCaptured = false;
            cap = new cv.VideoCapture(videoElement);
            let totalFrames = Math.floor(videoElement.duration * (videoElement.frameRate || 30));
            let frame = new cv.Mat(videoElement.videoHeight, videoElement.videoWidth, cv.CV_8UC4);
            videoElement.currentTime = 0;
            let currentFrame = 0;
            function grabFrame() {
                if (videoElement.currentTime >= videoElement.duration) {
                    allFramesCaptured = true;
                    frame.delete();
                    processFrames();
                    return;
                }
                cap.read(frame);
                framesArray.push(frame.clone());
                currentFrame++;
                // Avanza al siguiente frame
                videoElement.currentTime += 1 / (videoElement.frameRate || 30);
                setTimeout(grabFrame, 0);
            }
            grabFrame();
        };
        
        // Sobrescribe el evento onplay para capturar todos los frames solo una vez
        videoElement.onplay = () => {
            if (!allFramesCaptured) {
                extractAllFrames();
            }
        };
        
        // Nueva función para obtener los índices de los frames a procesar según la cadencia
        function getSelectedFrameIndices(total, selected) {
            if (selected >= total) {
                return Array.from({length: total}, (_, i) => i);
            }
            let step = (total - 1) / (selected - 1);
            let indices = [];
            for (let i = 0; i < selected; i++) {
                indices.push(Math.round(i * step));
            }
            console.log(indices)
            return indices;
        }
        
        // Modifica processFrames para usar solo los frames seleccionados
        const processFrames = () => {
            if (!allFramesCaptured || framesArray.length === 0) return;
            const canvas = document.getElementById('canvas');
            const canvasOutput = document.getElementById('canvasOutput');
            const strobeCanvas = document.getElementById('strobeCanvas');
            const strobeCtx = strobeCanvas.getContext('2d', { willReadFrequently: true });
            const backgroundCanvas = document.getElementById('backgroundCanvas');
            let isBackgroundPainted = false;
            videoElement.height = videoElement.videoHeight;
            videoElement.width = videoElement.videoWidth;
            let framePrev = new cv.Mat(videoElement.height, videoElement.width, cv.CV_8UC4);
            let gray = new cv.Mat();
            let grayPrev = new cv.Mat();
            let diff = new cv.Mat();
            let mask = new cv.Mat();
            let maskPrev = new cv.Mat();
            let maskDiff = new cv.Mat();
            let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
            let output = new cv.Mat(videoElement.height, videoElement.width, cv.CV_8UC4, new cv.Scalar(0,0,0,0));
            let background = new cv.Mat(videoElement.videoHeight, videoElement.videoWidth, cv.CV_8UC4);
            // Selecciona los índices de los frames a procesar
            let selectedCount = parseInt(cadenceSlider.value);
            let indices = getSelectedFrameIndices(framesArray.length, selectedCount);
            indices.forEach((idx, i) => {
                let frame = framesArray[idx];
                if (i === indices.length - 1) {
                    gray.delete(); grayPrev.delete();
                    diff.delete(); mask.delete(); kernel.delete();
                    maskPrev.delete(); maskDiff.delete(); framePrev.delete();
                    output.delete(); background.delete();
                    return;
                }
                cv.cvtColor(frame, gray, cv.COLOR_RGBA2GRAY);
                if (!isBackgroundPainted) {
                    frame.copyTo(background);
                    cv.imshow(canvas, background);
                    isBackgroundPainted = true;
                }
                if (!grayPrev.empty()) {
                    cv.absdiff(gray, grayPrev, diff);
                    cv.threshold(diff, mask, parseInt(inThresholdSlider.value), parseInt(outThresholdSlider.value), cv.THRESH_BINARY);
                    cv.morphologyEx(mask, mask, cv.MORPH_OPEN, kernel);
                    cv.imshow('canvasOutput', mask);
                    let result = new cv.Mat();
                    let rgbaPlanes = new cv.MatVector();
                    let rgb = new cv.Mat();
                    cv.cvtColor(framePrev, rgb, cv.COLOR_RGBA2RGB);
                    cv.split(rgb, rgbaPlanes);
                    rgbaPlanes.push_back(mask);
                    cv.merge(rgbaPlanes, result);
                    let tempCanvas = document.createElement('canvas');
                    tempCanvas.width = frame.width;
                    tempCanvas.height = frame.height;
                    let tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
                    cv.imshow(tempCanvas, result);
                    strobeCtx.drawImage(tempCanvas, 0, 0);
                    result.copyTo(background, mask);
                    cv.imshow(backgroundCanvas, background);
                }
                if (i !== indices.length - 1) {
                    gray.copyTo(grayPrev);
                    frame.copyTo(framePrev);
                }
            });
        };
        
        // Actualiza el label de la cadencia para mostrar el número de frames a procesar
        cadenceSlider.addEventListener('input', () => {
            cadence = parseInt(cadenceSlider.value);
            // cadenceValue.textContent = cadenceSlider.value;
            cadenceLabel.textContent = `Frames a procesar: ${cadence}`;
            if (allFramesCaptured) processFrames();
        });

        // Botón Play/Pause para el video
        playPauseBtn.addEventListener('click', function() {
            if (videoElement.paused) {
                videoElement.play();
                playPauseBtn.textContent = 'Pause';
            } else {
                videoElement.pause();
                playPauseBtn.textContent = 'Play';
            }
        });
        videoElement.addEventListener('play', function() {
            playPauseBtn.textContent = 'Pause';
        });
        videoElement.addEventListener('pause', function() {
            playPauseBtn.textContent = 'Play';
        });
        inThresholdSlider.addEventListener('change', () => {
        inThresholdValue.textContent = inThresholdSlider.value;
        processFrames();
        });

        outThresholdSlider.addEventListener('change', () => {
        outThresholdValue.textContent = outThresholdSlider.value;
        processFrames();
        });

        cadenceSlider.addEventListener('input', () => {
        cadence = parseInt(cadenceSlider.value);
        });

        // Botón para descargar la imagen del backgroundCanvas
        const downloadBackgroundBtn = document.getElementById('downloadBackgroundBtn');
        downloadBackgroundBtn.addEventListener('click', function() {
        const backgroundCanvas = document.getElementById('backgroundCanvas');
        const image = backgroundCanvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.href = image;
        link.download = 'background_final.png';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        });

        // Lógica para el botón Reset
        const resetAppBtn = document.getElementById('resetAppBtn');
        resetAppBtn.addEventListener('click', function() {
          // Limpiar todos los canvas
          ['canvas','canvasOutput','strobeCanvas','backgroundCanvas'].forEach(id => {
            const c = document.getElementById(id);
            const ctx = c.getContext('2d');
            ctx.clearRect(0, 0, c.width, c.height);
          });
          // Resetear variables y estados
          framesArray = [];
          allFramesCaptured = false;
          cadence = parseInt(cadenceSlider.value);
          inThresholdSlider.value = 10;
          outThresholdSlider.value = 200;
          inThresholdValue.textContent = '10';
          outThresholdValue.textContent = '200';
          cadenceSlider.value = 130;
        //   cadenceValue.textContent = '130';
          cadenceLabel.textContent = 'Frames a procesar: 130';
         
          // Mantener el video cargado y pausado al inicio
          videoElement.pause();
          videoElement.currentTime = 0;
          playPauseBtn.textContent = 'Play';
        });
       </script>
</body>
</html>
