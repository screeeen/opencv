<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>strobocam</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <h2>strobocam</h2>
  <div class="video-upload-container">
    <input type="file" id="videoInput" accept="video/*" class="video-input" />
    <label for="videoInput" class="video-input-label">Seleccionar Video</label>
  </div>
  <video id="video" muted>
    <source src="video.mov" type="video/mp4">
    Tu navegador no soporta video.
  </video>

  <div class="controls-container">
    <button id="playBtn" class="download-btn">Play</button>
  </div>

  <div class="controls-container">
    <div class="control-group">
      <label for="frameInterval">Guardar cada X frames:</label>
      <input type="number" id="frameInterval" value="6" min="1" />
    </div>

    <div class="control-group">
      <label for="inThreshold">Umbral Inferior:</label>
      <input type="range" id="inThreshold" min="1" max="50" value="10">
      <span id="inThresholdValue" class="threshold-value">10</span>
    </div>

    <div class="control-group">
      <label for="outThreshold">Umbral Superior:</label>
      <input type="range" id="outThreshold" min="100" max="255" value="200">
      <span id="outThresholdValue" class="threshold-value">200</span>
    </div>
  </div>
  
  <canvas id="canvasOutput" width="640" height="480"></canvas>

  <h3>strobo result</h3>
  
  <canvas id="strobeCanvas" width="640" height="480"></canvas>
  
  <div class="controls-container">
    <button id="downloadBtn" class="download-btn">Descargar Imagen Estroboscópica</button>
    <button id="resetBtn" class="download-btn">Reiniciar</button>
  </div>

  <!-- OpenCV.js -->
  <script async src="https://docs.opencv.org/4.7.0/opencv.js" onload="onOpenCvReady();"></script>

  <script>
    // Agregar el manejador de eventos para la carga de video
    document.getElementById('videoInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      const video = document.getElementById('video');
      video.src = URL.createObjectURL(file);
    });

    // Agregar control de reproducción
    const playBtn = document.getElementById('playBtn');
    const video = document.getElementById('video');

    playBtn.addEventListener('click', () => {
      if (video.paused) {
        video.play();
        playBtn.textContent = 'Pause';
      } else {
        video.pause();
        playBtn.textContent = 'Play';
      }
    });

    function onOpenCvReady() {
      const video = document.getElementById('video');
      
      // Actualizar dimensiones de los canvas cuando se carga el video
      video.addEventListener('loadedmetadata', () => {
        const canvasOutput = document.getElementById('canvasOutput');
        const strobeCanvas = document.getElementById('strobeCanvas');
        
        canvasOutput.width = video.videoWidth;
        canvasOutput.height = video.videoHeight;
        strobeCanvas.width = video.videoWidth;
        strobeCanvas.height = video.videoHeight;
      });

      video.addEventListener('play', () => {
        processVideo(video);
      });
    }

    function processVideo(video) {
      const canvas = document.getElementById('canvasOutput');
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      
      const strobeCanvas = document.getElementById('strobeCanvas');
      const strobeCtx = strobeCanvas.getContext('2d');

      const frameInput = document.getElementById('frameInterval');
      let frameCount = 0;

      // Obtener referencias a los sliders y sus valores
      const inThresholdSlider = document.getElementById('inThreshold');
      const outThresholdSlider = document.getElementById('outThreshold');
      const inThresholdValue = document.getElementById('inThresholdValue');
      const outThresholdValue = document.getElementById('outThresholdValue');

      // Actualizar valores mostrados cuando cambien los sliders
      inThresholdSlider.addEventListener('input', () => {
        inThresholdValue.textContent = inThresholdSlider.value;
      });

      outThresholdSlider.addEventListener('input', () => {
        outThresholdValue.textContent = outThresholdSlider.value;
      });

      let src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
      let gray = new cv.Mat();
      let grayPrev = new cv.Mat();
      let diff = new cv.Mat();
      let mask = new cv.Mat();
      let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
      let maskRGBA = new cv.Mat();
      let inThreshold = 10
      let outThreshold = 200;

      let background = null;
      
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      background = cv.imread(canvas);
   

      function updateFrame() {
        if (video.paused || video.ended) {


        background = new cv.Mat();
        src.copyTo(background);


          src.delete(); gray.delete(); grayPrev.delete();
          diff.delete(); mask.delete(); kernel.delete(); maskRGBA.delete();


          return;
        }

        ctx.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);
        let imageData = ctx.getImageData(0, 0, video.videoWidth, video.videoHeight);
        src.data.set(imageData.data);
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

        if (!grayPrev.empty()) {
          cv.absdiff(gray, grayPrev, diff);
          cv.threshold(diff, mask, parseInt(inThresholdSlider.value), parseInt(outThresholdSlider.value), cv.THRESH_BINARY);
          cv.morphologyEx(mask, mask, cv.MORPH_OPEN, kernel);
          cv.imshow('canvasOutput', mask);

          frameCount++;
          let frameInterval = parseInt(frameInput.value, 10);

          if (frameCount % frameInterval === 0) {
            // Convertimos la máscara a RGBA para superponer
            cv.cvtColor(mask, maskRGBA, cv.COLOR_GRAY2RGBA);

            // Dibujamos sobre el canvas final como una estampa
            let tempCanvas = document.createElement('canvas');
            tempCanvas.width = video.videoWidth;
            tempCanvas.height = video.videoHeight;
            let tempCtx = tempCanvas.getContext('2d');
            cv.imshow(tempCanvas, mask);

            let result = new cv.Mat();
            let rgbaPlanes = new cv.MatVector();
            let rgb = new cv.Mat();

            // Separar los canales RGB
            cv.cvtColor(src, rgb, cv.COLOR_RGBA2RGB);
            cv.split(rgb, rgbaPlanes); // R, G, B

			cv.bitwise_not(mask, mask);

            // Agregar canal alfa según la máscara
            rgbaPlanes.push_back(mask); // el blanco será opaco, negro será transparente

            // Unir canales RGBA
            cv.merge(rgbaPlanes, result);


            // Mostrar el resultado
            // cv.imshow(maskCanvas, mask);

            cv.imshow(tempCanvas, result);

            // Liberar memoria
            // src.delete(); gray.delete(); mask.delete(); kernel.delete();
            // rgb.delete(); result.delete(); rgbaPlanes.delete();




            // Usamos "lighten" para mezclar los frames blancos (movimiento)
            // maskCtx.globalCompositeOperation = 'lighten';
            // maskCtx.drawImage(tempCanvas, 0, 0);

            strobeCtx.globalCompositeOperation = 'xor';
            strobeCtx.drawImage(tempCanvas, 0, 0);
          }



                // cv.imshow(maskCanvas, background);
        }

        gray.copyTo(grayPrev);
        requestAnimationFrame(updateFrame);
      }


      requestAnimationFrame(updateFrame);
    }

    // Función para descargar la imagen estroboscópica
    document.getElementById('downloadBtn').addEventListener('click', () => {
      const strobeCanvas = document.getElementById('strobeCanvas');
      const link = document.createElement('a');
      link.download = 'imagen_estroboscopica.png';
      link.href = strobeCanvas.toDataURL('image/png');
      link.click();
    });

    // Función para reiniciar la aplicación
    document.getElementById('resetBtn').addEventListener('click', () => {
      const strobeCanvas = document.getElementById('strobeCanvas');
      const strobeCtx = strobeCanvas.getContext('2d');
      strobeCtx.clearRect(0, 0, strobeCanvas.width, strobeCanvas.height);
      frameCount = 0;
      
      // Reiniciar el video
      video.pause();
      video.currentTime = 0;
      playBtn.textContent = 'Play';
    });
  </script>
</body>
</html>
